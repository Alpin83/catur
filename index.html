<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Modern Chess Game</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <style>
    /* Reset and base */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      height: 100%;
      font-family: 'Inter', sans-serif, Arial, sans-serif;
      background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    #app {
      display: grid;
      grid-template-columns: 280px 1fr 280px;
      grid-template-rows: 60px 1fr 80px;
      grid-template-areas:
        "header header header"
        "sidebar main controls"
        "footer footer footer";
      height: 100vh;
      gap: 16px;
      padding: 16px;
    }

    /* HEADER */
    header {
      grid-area: header;
      background: linear-gradient(90deg, #120428cc, #6819a5cc);
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      box-shadow: 0 0 12px #6819a5cc;
      color: #ffffff;
      user-select: none;
      position: relative;
    }
    header .title {
      font-weight: 900;
      font-size: 1.5rem;
      letter-spacing: 1.2px;
      text-shadow: 0 0 10px #a27aff;
    }
    header .status {
      display: flex;
      align-items: center;
      gap: 24px;
      font-weight: 600;
      font-size: 1rem;
      min-width: 400px;
      justify-content: flex-end;
    }
    header .status div {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    header .status .icon {
      font-size: 20px;
      color: #e5d4ff;
      filter: drop-shadow(0 0 4px #9c85f0);
    }

    /* SIDEBAR */
    aside.sidebar {
      grid-area: sidebar;
      background: #150c2fcc;
      border-radius: 16px;
      padding: 24px 20px;
      display: flex;
      flex-direction: column;
      gap: 32px;
      overflow-y: auto;
      box-shadow: 0 0 24px #8d7ed6aa;
    }
    aside.sidebar h2 {
      font-weight: 800;
      font-size: 1.3rem;
      color: #c4afff;
      margin-bottom: 8px;
      text-align: center;
      text-shadow: 0 0 8px #a27aff;
    }
    aside.sidebar section {
      background: #271d4e;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 0 12px #6e5eac;
      font-size: 0.9rem;
      line-height: 1.4;
      color: #ddd;
    }
    aside.sidebar section.collapsible > summary {
      cursor: pointer;
      font-weight: 700;
      color: #c0baff;
      list-style: none;
      outline-offset: 4px;
      user-select: none;
      padding-bottom: 10px;
      border-bottom: 1px solid #6e5eac66;
    }
    aside.sidebar section.collapsible > summary::-webkit-details-marker {
      display: none;
    }
    aside.sidebar section.collapsible[open] > summary {
      color: #dcd6ff;
      text-shadow: 0 0 8px #b3a6ff;
    }

    /* MAIN AREA */
    main#main {
      grid-area: main;
      background: #000000dd;
      border-radius: 20px;
      box-shadow: 0 0 20px #a080ffbb inset;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      overflow: hidden;
    }
    canvas#chessboard {
      width: 100%;
      height: 100%;
      max-width: 640px;
      max-height: 640px;
      border-radius: 20px;
      box-shadow:
        0 0 15px #9c85f0,
        inset 0 0 30px #7f5ced;
      cursor: pointer;
      user-select: none;
      background: radial-gradient(circle at center, #2f2358 50%, #0c0819 95%);
    }

    /* CONTROLS PANEL (RIGHT) */
    section#controls {
      grid-area: controls;
      background: #150c2fcc;
      border-radius: 16px;
      padding: 24px 20px;
      display: flex;
      flex-direction: column;
      gap: 28px;
      box-shadow: 0 0 20px #876bdbbb;
      color: #d4cdff;
      overflow-y: auto;
    }
    section#controls h2 {
      font-weight: 800;
      font-size: 1.3rem;
      color: #c4afff;
      margin-bottom: 8px;
      text-align: center;
      text-shadow: 0 0 8px #a27aff;
    }
    section#controls div {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 0 10px;
    }
    #controls button.action-btn {
      background: linear-gradient(135deg, #845ef7, #5e3cf7);
      border: none;
      border-radius: 12px;
      color: white;
      font-weight: 700;
      font-size: 0.95rem;
      cursor: pointer;
      padding: 12px 0;
      box-shadow: 0 0 8px #6f52e6;
      text-align: center;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      user-select: none;
    }
    #controls button.action-btn:hover {
      box-shadow: 0 0 18px #a085ff;
      transform: scale(1.05);
    }
    #controls .volume-control {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    #controls input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      background: transparent;
      cursor: pointer;
    }
    #controls input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      background: linear-gradient(135deg, #845ef7, #5e3cf7);
      border-radius: 4px;
    }
    #controls input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      border: none;
      height: 20px;
      width: 20px;
      border-radius: 50%;
      background: #fff;
      margin-top: -7px;
      box-shadow: 0 0 6px #a085ff;
      transition: box-shadow 0.3s ease;
    }
    #controls input[type="range"]:focus::-webkit-slider-thumb {
      box-shadow: 0 0 14px #d1c1ff;
    }

    /* FOOTER */
    footer {
      grid-area: footer;
      background: linear-gradient(90deg, #120428cc, #6819a5cc);
      border-radius: 16px;
      padding: 12px 24px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: #d4ccffaa;
      font-size: 0.875rem;
      user-select: none;
      box-shadow: 0 0 12px #6819a5cc;
      flex-wrap: wrap;
      gap: 8px;
    }
    footer a {
      color: #b3a6ff;
      text-decoration: none;
      transition: color 0.3s ease;
    }
    footer a:hover,
    footer a:focus {
      color: #dcd6ff;
    }

    /* Neon glowing highlights for active player */
    .player-white, .player-black {
      position: relative;
      padding: 4px 12px;
      border-radius: 16px;
      font-weight: 700;
      user-select: none;
      cursor: default;
    }
    .player-white {
      color: #eeeeee;
      background: linear-gradient(135deg, #94a3b8, #a6adcc);
      box-shadow: 0 0 16px #d6dbffaa inset;
    }
    .player-black {
      color: #e6d0ff;
      background: linear-gradient(135deg, #7b52d6, #8e63e7);
      box-shadow: 0 0 30px #a18df7bb inset;
    }
    .player-active {
      box-shadow:
        0 0 12px 4px #c098ff88,
        0 0 24px 8px #e4c9ff99;
      animation: neonPulse 2.2s infinite alternate ease-in-out;
    }
    @keyframes neonPulse {
      0% {
        box-shadow:
          0 0 14px 6px #c098ffdd,
          0 0 30px 8px #e4c9ffbb;
      }
      100% {
        box-shadow:
          0 0 20px 8px #e0b4ffdd,
          0 0 40px 12px #f0d4ffdd;
      }
    }

    /* CHESSBOARD GRID HIGHLIGHTS & MOVEMENT INDICATORS */
    .highlight-move {
      fill: rgba(75, 54, 190, 0.7);
      filter: drop-shadow(0 0 6px #6557f7);
    }
    .highlight-attack {
      fill: rgba(195, 54, 75, 0.8);
      filter: drop-shadow(0 0 10px #e8647f);
    }
    .highlight-check {
      stroke: #ff567a;
      stroke-width: 4;
      filter: drop-shadow(0 0 8px #ff567aaa);
    }

    /* PIECE ANIMATIONS */
    @keyframes piece-move {
      from {
        filter: drop-shadow(0 0 4px #8b5cf6);
      }
      to {
        filter: drop-shadow(0 0 14px #bb92ff);
      }
    }

    /* Responsive adjustments */
    @media (max-width: 1024px) {
      #app {
        grid-template-columns: 220px 1fr;
        grid-template-rows: 60px 1fr 80px;
        grid-template-areas:
          "header header"
          "sidebar main"
          "footer footer";
      }
      section#controls {
        display: none;
      }
      aside.sidebar {
        max-height: 370px;
      }
    }
    @media (max-width: 768px) {
      #app {
        grid-template-columns: 1fr;
        grid-template-rows: 60px 1fr 80px 180px;
        grid-template-areas:
          "header"
          "main"
          "controls"
          "footer";
        padding: 12px;
      }
      aside.sidebar,
      section#controls {
        display: none;
      }
      main#main {
        max-width: 100vw;
      }
      canvas#chessboard {
        max-width: 100vw;
        max-height: 100vw;
        aspect-ratio: 1;
      }
    }

    /* Scrollbar styling for sidebar */
    aside.sidebar::-webkit-scrollbar {
      width: 8px;
    }
    aside.sidebar::-webkit-scrollbar-track {
      background: #241b4c;
      border-radius: 8px;
    }
    aside.sidebar::-webkit-scrollbar-thumb {
      background: #6f5ed9cc;
      border-radius: 8px;
    }

    /* Achievement popup container */
    #achievement-popup {
      position: fixed;
      top: 96px;
      right: 32px;
      background: linear-gradient(135deg, #651fffcc, #ea80fccc);
      border-radius: 12px;
      box-shadow: 0 0 24px #a259ffbb;
      color: white;
      font-weight: 700;
      padding: 16px 24px;
      display: none;
      align-items: center;
      gap: 12px;
      z-index: 999;
      animation: slideInRight 0.5s ease forwards;
      max-width: 300px;
      user-select: none;
    }
    #achievement-popup.show {
      display: flex;
    }
    #achievement-popup .material-icons {
      font-size: 32px;
      filter: drop-shadow(0 0 6px #f0a9ff);
    }
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

  </style>
</head>
<body>
  <div id="app" role="application" aria-label="Chess Game Application">
    <header role="banner">
      <div class="title" aria-live="polite">Modern Neon Chess</div>
      <div class="status" role="region" aria-label="Game status">
        <div class="player-white player-active" id="white-turn-indicator" aria-live="polite" aria-atomic="true" tabindex="0">
          <span class="material-icons icon" aria-hidden="true">brightness_5</span> White's Turn
        </div>
        <div class="player-black" id="black-turn-indicator" aria-live="polite" aria-atomic="true" tabindex="0">
          <span class="material-icons icon" aria-hidden="true">brightness_2</span> Black's Turn
        </div>
        <div aria-live="polite" aria-atomic="true" id="game-timer" tabindex="0" style="display:flex; align-items:center;">
          <span class="material-icons icon" aria-hidden="true">timer</span> <span id="timer-value">00:00</span>
        </div>
      </div>
    </header>

    <aside class="sidebar" aria-label="Game information and controls sidebar">
      <h2>Game Info & Achievements</h2>

      <section>
        <h3>Controls</h3>
        <p>
          - Click/tap or drag pieces to move.<br/>
          - Use Undo or Restart buttons below.<br/>
          - Keyboard: Arrow keys to navigate squares, Enter to select/move piece.<br/>
          - Check and checkmate are indicated visually.<br/>
          - Toggle sound/music via controls.
        </p>
      </section>

      <section class="collapsible" open>
        <summary>Achievements</summary>
        <ul id="achievements-list" aria-live="polite" style="list-style:none; padding-left: 12px; max-height: 200px; overflow-y: auto;">
          <!-- Achievements will be dynamically inserted here -->
        </ul>
      </section>

      <section class="collapsible" open>
        <summary>Power-Ups</summary>
        <div id="powerups-list">No power-ups yet.</div>
      </section>

    </aside>

    <main id="main" role="main">
      <canvas id="chessboard" width="640" height="640" aria-label="Chess game board" tabindex="0"></canvas>
    </main>

    <section id="controls" role="region" aria-label="Game controls panel">
      <h2>Controls</h2>
      <div>
        <button class="action-btn" id="btn-undo" aria-label="Undo last move">
          <span class="material-icons" aria-hidden="true">undo</span> Undo
        </button>
        <button class="action-btn" id="btn-restart" aria-label="Restart game">
          <span class="material-icons" aria-hidden="true">refresh</span> Restart
        </button>
      </div>
      <div>
        <label for="sound-volume" class="material-icons" aria-label="Sound volume control">volume_up</label>
        <input type="range" id="sound-volume" min="0" max="1" step="0.01" value="0.5" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0.5" aria-label="Sound effects volume slider" />
      </div>
      <div>
        <label for="music-volume" class="material-icons" aria-label="Music volume control">music_note</label>
        <input type="range" id="music-volume" min="0" max="1" step="0.01" value="0.3" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0.3" aria-label="Background music volume slider" />
      </div>
      <div>
        <button class="action-btn" id="btn-pause" aria-label="Pause or resume game">
          <span class="material-icons" aria-hidden="true">pause_circle_filled</span> Pause / Resume
        </button>
      </div>
    </section>

    <footer role="contentinfo">
      <div>Modern Neon Chess Game &copy; 2024</div>
      <div>
        <a href="https://github.com" target="_blank" rel="noopener noreferrer" aria-label="GitHub Repository">GitHub</a> | 
        <a href="https://lichess.org" target="_blank" rel="noopener noreferrer" aria-label="Lichess Online Chess Platform">Lichess</a> | 
        <a href="https://www.chess.com" target="_blank" rel="noopener noreferrer" aria-label="Chess.com Online Chess Platform">Chess.com</a>
      </div>
    </footer>

    <div id="achievement-popup" role="alert" aria-live="assertive" aria-atomic="true" aria-relevant="additions"></div>
  </div>

  <script>
    "use strict";

    /********************
     * Data structures and game state
     ********************/

    // Board is 8x8 squares, files 'a'..'h', ranks '1'..'8' mapped
    // internally to 0..7 indices for rows and columns.

    // Pieces represented by object {type: 'p','r','n','b','q','k', color: 'w'|'b'}
    // with standard chess notation:
    // p = pawn, r = rook, n = knight, b = bishop, q = queen, k = king

    // Full game state with all requested properties.
    const gameState = {
      board: [], // 8x8 matrix with pieces or null
      history: [], // history of moves for undo
      whiteToMove: true,
      selectedPiece: null,
      legalMoves: [],
      lastMove: null,
      gameOver: false,
      winner: null,
      promotionPending: null,
      score: 0, // material count
      level: 1,
      timerStart: 0,
      timerElapsed: 0,
      timerIntervalId: null,
      achievements: [],
      unlockedAchievements: {},
      powerUps: [],
      settings: {
        soundVolume: 0.5,
        musicVolume: 0.3,
        graphics: 'high',
        controls: 'mouse',
        fullscreen: false,
      },
      audio: {
        sounds: {},
        music: null,
      },
      particles: [],
      inputState: {
        mouseDown: false,
        dragOrigin: null,
        dragPiece: null,
        dragStartPos: null,
      },
      animationState: {
        movingPiece: null,
        animationProgress: 0,
        animationDuration: 300,
        animationFrom: null,
        animationTo: null,
      }
    };

    // Piece values for material score calculation
    const pieceValues = {
      p: 1,
      n: 3,
      b: 3,
      r: 5,
      q: 9,
      k: 0
    };

    // Directions for piece moves
    const directions = {
      n: [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
      b: [[-1,-1],[-1,1],[1,-1],[1,1]],
      r: [[-1,0],[1,0],[0,-1],[0,1]],
      q: [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]],
      k: [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]],
    };

    // Map board coordinates to algebraic notation
    function coordsToAlgebraic(row, col) {
      return 'abcdefgh'[col] + (8 - row);
    }
    function algebraicToCoords(pos) {
      const col = 'abcdefgh'.indexOf(pos[0]);
      const row = 8 - parseInt(pos[1], 10);
      return [row,col];
    }

    // Subtle utility clamp
    function clamp(num, min, max) {
      return Math.min(Math.max(num, min), max);
    }

    /********************
     * Initialize board data
     ********************/
    function setupBoard() {
      // Empty 8x8 matrix
      gameState.board = new Array(8).fill(null).map(() => new Array(8).fill(null));

      // Place black pieces
      const blackMajor = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'];
      for(let i=0; i<8; i++) {
        gameState.board[0][i] = {type: blackMajor[i], color: 'b'};
        gameState.board[1][i] = {type: 'p', color: 'b'};
      }
      // Place white pieces
      const whiteMajor = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'];
      for(let i=0; i<8; i++) {
        gameState.board[7][i] = {type: whiteMajor[i], color: 'w'};
        gameState.board[6][i] = {type: 'p', color: 'w'};
      }

      gameState.whiteToMove = true;
      gameState.selectedPiece = null;
      gameState.legalMoves = [];
      gameState.lastMove = null;
      gameState.gameOver = false;
      gameState.winner = null;
      gameState.history = [];
      gameState.timerStart = performance.now();
      gameState.timerElapsed = 0;
      resetTimer();
      updateTurnDisplay();
    }

    /********************
     * Canvas and constants
     ********************/
    const canvas = document.getElementById('chessboard');
    const ctx = canvas.getContext('2d');
    const boardSize = 640;
    const squareSize = boardSize / 8;

    // Neon colors
    const colors = {
      lightSquare: '#4b3a8e',
      darkSquare: '#291f46',
      highlightMove: 'rgba(120, 100, 255, 0.55)',
      highlightAttack: 'rgba(255, 70, 90, 0.75)',
      gridStroke: '#674ccf',
      checkHighlight: '#ff4477',
      glow: '#a48eff',
      selectedGlow: '#6495ed',
      textGlow: '#e3d9ff',
      pieceGlow: '#ab8aff',
    };

    /********************
     * Load piece images
     ********************/
    const pieceImages = {};
    // We'll draw basic pieces using canvas shapes and text with neon effects for now.

    /********************
     * UI References
     ********************/
    const whiteTurnElem = document.getElementById('white-turn-indicator');
    const blackTurnElem = document.getElementById('black-turn-indicator');
    const timerValueElem = document.getElementById('timer-value');
    const achievementsListElem = document.getElementById('achievements-list');
    const achievementPopupElem = document.getElementById('achievement-popup');
    const powerupsListElem = document.getElementById('powerups-list');
    const btnUndo = document.getElementById('btn-undo');
    const btnRestart = document.getElementById('btn-restart');
    const btnPause = document.getElementById('btn-pause');
    const soundVolumeInput = document.getElementById('sound-volume');
    const musicVolumeInput = document.getElementById('music-volume');

    /********************
     * Audio setup
     ********************/
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    function playNote(freq, duration=0.15) {
      if (gameState.settings.soundVolume === 0) return;
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.type = 'triangle';
      oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
      gainNode.gain.setValueAtTime(gameState.settings.soundVolume, audioContext.currentTime);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + duration);
      oscillator.onended = () => {
        gainNode.disconnect();
        oscillator.disconnect();
      };
    }
    function playSound(soundName) {
      // Basic sounds simulation
      switch(soundName) {
        case 'move':
          playNote(600, 0.1);
          break;
        case 'capture':
          playNote(400, 0.2);
          playNote(300, 0.1);
          break;
        case 'check':
          playNote(800, 0.3);
          break;
        case 'gameover':
          playNote(300, 0.6);
          break;
      }
    }

    /********************
     * Drawing utilities
     ********************/

    function drawBoard() {
      ctx.clearRect(0, 0, boardSize, boardSize);
      // Draw squares
      for(let row=0; row<8; row++) {
        for(let col=0; col<8; col++) {
          const isLight = (row + col) % 2 === 0;
          ctx.fillStyle = isLight ? colors.lightSquare : colors.darkSquare;
          ctx.shadowColor = 'transparent';
          ctx.fillRect(col*squareSize, row*squareSize, squareSize, squareSize);
        }
      }
      // Draw grid lines
      ctx.strokeStyle = colors.gridStroke;
      ctx.lineWidth = 1;
      for(let i=0; i<=8; i++) {
        ctx.beginPath();
        ctx.moveTo(i*squareSize, 0);
        ctx.lineTo(i*squareSize, boardSize);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, i*squareSize);
        ctx.lineTo(boardSize, i*squareSize);
        ctx.stroke();
      }
    }

    // Draw glowing squares to highlight legal moves
    function drawHighlights() {
      gameState.legalMoves.forEach(move => {
        const {row, col, type} = move;
        if(type === 'move') {
          ctx.fillStyle = colors.highlightMove;
        } else if(type === 'attack') {
          ctx.fillStyle = colors.highlightAttack;
        }
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 12;
        ctx.fillRect(col*squareSize+2, row*squareSize+2, squareSize-4, squareSize-4);
        ctx.shadowBlur = 0;
      });

      // Highlight last move squares
      if(gameState.lastMove) {
        ctx.fillStyle = 'rgba(255,255,100,0.3)';
        ctx.fillRect(gameState.lastMove.fromCol*squareSize, gameState.lastMove.fromRow*squareSize, squareSize, squareSize);
        ctx.fillRect(gameState.lastMove.toCol*squareSize, gameState.lastMove.toRow*squareSize, squareSize, squareSize);
      }

      // Highlight king in check
      const checkKingPos = findKingInCheck();
      if(checkKingPos) {
        ctx.strokeStyle = colors.checkHighlight;
        ctx.lineWidth = 4;
        ctx.shadowColor = colors.checkHighlight;
        ctx.shadowBlur = 18;
        ctx.strokeRect(checkKingPos.col*squareSize+2, checkKingPos.row*squareSize+2, squareSize-4, squareSize-4);
        ctx.shadowBlur = 0;
      }
    }

    // Draw pieces with neon glow effect using vector shapes and glow filters on text
    function drawPieces() {
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "48px 'Segoe UI Symbol', Arial, sans-serif";
      ctx.lineWidth = 2;

      // Unicode symbols for chess pieces white + black
      const unicodePieces = {
        pw: '\u2659', pb: '\u265F',
        rw: '\u2656', rb: '\u265C',
        nw: '\u2658', nb: '\u265E',
        bw: '\u2657', bb: '\u265D',
        qw: '\u2655', qb: '\u265B',
        kw: '\u2654', kb: '\u265A'
      };

      for(let row=0; row<8; row++) {
        for(let col=0; col<8; col++) {
          const piece = gameState.board[row][col];
          if(piece) {
            let symbol = unicodePieces[piece.type + piece.color];
            let px = col*squareSize + squareSize/2;
            let py = row*squareSize + squareSize/2;

            // Glow effect by drawing shadow text
            ctx.shadowColor = piece.color === 'w' ? '#d3d3ffcc' : '#b080ffcc';
            ctx.shadowBlur = 16;
            ctx.fillStyle = piece.color === 'w' ? '#f0f0ff' : '#d2abff';
            ctx.fillText(symbol, px, py);
            ctx.shadowBlur = 0;
          }
        }
      }
    }

    // Draw selection rectangle with glow
    function drawSelection() {
      if(gameState.selectedPiece) {
        ctx.fillStyle = colors.selectedGlow;
        ctx.shadowColor = colors.selectedGlow;
        ctx.shadowBlur = 12;
        ctx.fillRect(gameState.selectedPiece.col*squareSize+4, gameState.selectedPiece.row*squareSize+4, squareSize-8, squareSize-8);
        ctx.shadowBlur = 0;
      }
    }

    /********************
     * Chess logic utilities
     ********************/
    // Inside chess move generation, validation, and check detection

    // Position inside board?
    function inBounds(r,c) {
      return r >= 0 && r < 8 && c >= 0 && c < 8;
    }

    // Find all legal moves for a piece at position (row,col)
    // Return an array of moves {row, col, type: 'move'|'attack'}
    function findLegalMoves(row, col) {
      const piece = gameState.board[row][col];
      if(!piece) return [];
      const moves = [];
      const enemyColor = piece.color === 'w' ? 'b' : 'w';

      switch(piece.type) {
        case 'p': {
          // Pawn moves
          let forward = piece.color === 'w' ? -1 : 1;
          let startRow = piece.color === 'w' ? 6 : 1;

          // Forward move
          let r1 = row + forward;
          if(inBounds(r1, col) && gameState.board[r1][col] == null) {
            moves.push({row: r1, col: col, type: 'move'});
            // Two square first move
            if(row === startRow && gameState.board[r1 + forward]?.[col] == null) {
              moves.push({row: r1 + forward, col: col, type: 'move'});
            }
          }
          // Captures
          for(const dc of [-1,1]) {
            let c1 = col + dc;
            if(inBounds(r1, c1)) {
              const target = gameState.board[r1][c1];
              if(target && target.color === enemyColor) {
                moves.push({row: r1, col: c1, type: 'attack'});
              }
              // TODO: Implement en passant capture later if time permits
            }
          }
          break;
        }
        case 'n': {
          // Knight moves (L shape)
          directions.n.forEach(([dr, dc]) => {
            let r1 = row + dr;
            let c1 = col + dc;
            if(inBounds(r1,c1)) {
              const target = gameState.board[r1][c1];
              if(!target) {
                moves.push({row: r1, col: c1, type: 'move'});
              } else if(target.color === enemyColor) {
                moves.push({row: r1, col: c1, type: 'attack'});
              }
            }
          });
          break;
        }
        case 'b': {
          // Bishop moves: diagonal sliding
          directions.b.forEach(([dr, dc]) => {
            let r1 = row + dr;
            let c1 = col + dc;
            while(inBounds(r1,c1)) {
              const target = gameState.board[r1][c1];
              if(!target) {
                moves.push({row: r1, col: c1, type: 'move'});
              } else {
                if(target.color === enemyColor) {
                  moves.push({row: r1, col: c1, type: 'attack'});
                }
                break;
              }
              r1 += dr;
              c1 += dc;
            }
          });
          break;
        }
        case 'r': {
          // Rook moves: orthogonal sliding
          directions.r.forEach(([dr, dc]) => {
            let r1 = row + dr;
            let c1 = col + dc;
            while(inBounds(r1,c1)) {
              const target = gameState.board[r1][c1];
              if(!target) {
                moves.push({row: r1, col: c1, type: 'move'});
              } else {
                if(target.color === enemyColor) {
                  moves.push({row: r1, col: c1, type: 'attack'});
                }
                break;
              }
              r1 += dr;
              c1 += dc;
            }
          });
          break;
        }
        case 'q': {
          // Queen moves: combination rook + bishop
          directions.q.forEach(([dr, dc]) => {
            let r1 = row + dr;
            let c1 = col + dc;
            while(inBounds(r1,c1)) {
              const target = gameState.board[r1][c1];
              if(!target) {
                moves.push({row: r1, col: c1, type: 'move'});
              } else {
                if(target.color === enemyColor) {
                  moves.push({row: r1, col: c1, type: 'attack'});
                }
                break;
              }
              r1 += dr;
              c1 += dc;
            }
          });
          break;
        }
        case 'k': {
          // King moves: one step in any direction + castling possibility (not yet implemented)
          directions.k.forEach(([dr, dc]) => {
            let r1 = row + dr;
            let c1 = col + dc;
            if(inBounds(r1,c1)) {
              const target = gameState.board[r1][c1];
              if(!target) {
                moves.push({row: r1, col: c1, type: 'move'});
              } else if(target.color === enemyColor) {
                moves.push({row: r1, col: c1, type: 'attack'});
              }
            }
          });
          // Castling TODO
          break;
        }
      }
      return moves;
    }

    // Check if current player is in check
    // Returns position of king if in check, otherwise null
    function findKingInCheck() {
      let kingPos = null;
      const colorToCheck = gameState.whiteToMove ? 'w' : 'b';
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          const p = gameState.board[r][c];
          if(p && p.type === 'k' && p.color === colorToCheck) {
            kingPos = {row: r, col: c};
            break;
          }
        }
      }
      if(!kingPos) return null;

      // Check opponent moves can capture king
      const opponentColor = colorToCheck === 'w' ? 'b' : 'w';

      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          const p = gameState.board[r][c];
          if(p && p.color === opponentColor) {
            const moves = findLegalMoves(r, c);
            for(const m of moves) {
              if(m.row === kingPos.row && m.col === kingPos.col) {
                return kingPos;
              }
            }
          }
        }
      }
      return null;
    }

    // Validate if move does not expose own king to check
    // moveFrom: {row,col} moveTo: {row,col}
    function isMoveLegal(moveFrom, moveTo) {
      // Make a copy of board
      const boardCopy = gameState.board.map(r => r.slice());
      const piece = boardCopy[moveFrom.row][moveFrom.col];
      if(!piece) return false;
      // Move the piece
      boardCopy[moveTo.row][moveTo.col] = piece;
      boardCopy[moveFrom.row][moveFrom.col] = null;

      // Find king pos for moving color
      let kingPos = null;
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          const p = boardCopy[r][c];
          if(p && p.type === 'k' && p.color === piece.color) {
            kingPos = {row: r, col: c};
            break;
          }
        }
      }
      if(!kingPos) return false;

      // Check if any opponent piece attacks king pos
      const opponentColor = piece.color === 'w' ? 'b' : 'w';
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          const p = boardCopy[r][c];
          if(p && p.color === opponentColor) {
            const moves = findLegalMoves(r, c);
            for(const m of moves) {
              if(m.row === kingPos.row && m.col === kingPos.col) {
                return false;
              }
            }
          }
        }
      }
      return true;
    }

    /********************
     * Select piece and highlights
     ********************/
    function selectSquare(row, col) {
      if(gameState.gameOver) return;
      const piece = gameState.board[row][col];
      if(gameState.selectedPiece) {
        // Try to move selected piece to new square if legal
        const selected = gameState.selectedPiece;
        const possibleMoves = gameState.legalMoves;
        const canMoveHere = possibleMoves.some(m => m.row === row && m.col === col);
        if(canMoveHere) {
          movePiece(selected.row, selected.col, row, col);
          clearSelection();
        } else if(piece && piece.color === (gameState.whiteToMove ? 'w' : 'b')) {
          // reselect another piece
          gameState.selectedPiece = {row, col};
          updateLegalMoves();
        } else {
          clearSelection();
        }
      } else {
        if(piece && piece.color === (gameState.whiteToMove ? 'w' : 'b')) {
          gameState.selectedPiece = {row, col};
          updateLegalMoves();
        }
      }
    }
    function clearSelection() {
      gameState.selectedPiece = null;
      gameState.legalMoves = [];
    }

    // Calculate legal moves of selected piece filtered by check rule
    function updateLegalMoves() {
      if(!gameState.selectedPiece) {
        gameState.legalMoves = [];
        return;
      }
      const {row, col} = gameState.selectedPiece;
      const rawMoves = findLegalMoves(row, col);
      // Filter moves that cause self-check
      const filtered = rawMoves.filter(m =>
        isMoveLegal({row, col}, {row: m.row, col: m.col})
      );
      gameState.legalMoves = filtered;
    }

    // Move a piece and update game state
    function movePiece(fromRow, fromCol, toRow, toCol) {
      if(gameState.gameOver) return;
      const movingPiece = gameState.board[fromRow][fromCol];
      const targetPiece = gameState.board[toRow][toCol];

      // Start animation state for piece move
      gameState.animationState.movingPiece = movingPiece;
      gameState.animationState.animationProgress = 0;
      gameState.animationState.animationFrom = {row: fromRow, col: fromCol};
      gameState.animationState.animationTo = {row: toRow, col: toCol};

      // Update board immediately to reflect move (though drawing will animate)
      gameState.board[toRow][toCol] = movingPiece;
      gameState.board[fromRow][fromCol] = null;

      // Save move to history
      gameState.history.push({
        fromRow, fromCol, toRow, toCol,
        piece: movingPiece,
        captured: targetPiece,
        prevWhiteToMove: gameState.whiteToMove,
      });

      gameState.lastMove = {fromRow, fromCol, toRow, toCol};
      playSound(targetPiece ? 'capture' : 'move');

      // Promotion check
      if(movingPiece.type === 'p' && (toRow === 0 || toRow === 7)) {
        gameState.promotionPending = {row: toRow, col: toCol, color: movingPiece.color};
      }

      // Toggle player turn
      gameState.whiteToMove = !gameState.whiteToMove;
      updateTurnDisplay();

      // Clear selection & legal moves, reset timer
      clearSelection();
      updateLegalMoves();
      resetTimer();

      // Check game over conditions
      checkGameOver();

      // Update power-ups and achievements if implemented
      // Placeholder: No power-ups or achievements implemented yet
    }

    function undoMove() {
      if(gameState.history.length === 0 || gameState.gameOver) return;
      const last = gameState.history.pop();
      // Undo move on board
      gameState.board[last.fromRow][last.fromCol] = last.piece;
      gameState.board[last.toRow][last.toCol] = last.captured;

      gameState.whiteToMove = last.prevWhiteToMove;
      updateTurnDisplay();
      gameState.lastMove = null;
      clearSelection();
      updateLegalMoves();
      resetTimer();
      playSound('move');
    }

    function restartGame() {
      setupBoard();
      clearSelection();
      updateLegalMoves();
      playSound('move');
      gameState.gameOver = false;
      gameState.winner = null;
      resetTimer();
    }

    /********************
     * Game over and checkmate
     ********************/
    function checkGameOver() {
      // Check if current player has any legal moves
      const hasLegalMoves = hasAnyLegalMoves();
      const kingInCheck = !!findKingInCheck();

      if(!hasLegalMoves) {
        gameState.gameOver = true;
        if(kingInCheck) {
          gameState.winner = gameState.whiteToMove ? 'Black' : 'White';
          showGameOverScreen(gameState.winner + ' wins by checkmate!');
          playSound('gameover');
        } else {
          gameState.winner = 'Draw';
          showGameOverScreen('Game is a stalemate!');
          playSound('gameover');
        }
      }
    }

    function hasAnyLegalMoves() {
      const color = gameState.whiteToMove ? 'w' : 'b';
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          const piece = gameState.board[r][c];
          if(piece && piece.color === color) {
            const moves = findLegalMoves(r, c);
            const legal = moves.filter(m => isMoveLegal({row:r, col:c}, {row:m.row, col:m.col}));
            if(legal.length > 0) return true;
          }
        }
      }
      return false;
    }

    function showGameOverScreen(message) {
      alert(message + "\nPress Restart to play again.");
    }

    /********************
     * Timers and UI updates
     ********************/
    function updateTurnDisplay() {
      if(gameState.whiteToMove) {
        whiteTurnElem.classList.add('player-active');
        blackTurnElem.classList.remove('player-active');
      } else {
        blackTurnElem.classList.add('player-active');
        whiteTurnElem.classList.remove('player-active');
      }
    }

    function resetTimer() {
      gameState.timerStart = performance.now();
      gameState.timerElapsed = 0;
      updateTimerDisplay();
      if(gameState.timerIntervalId) {
        clearInterval(gameState.timerIntervalId);
      }
      gameState.timerIntervalId = setInterval(() => {
        if(!gameState.gameOver && !gameState.isPaused) {
          gameState.timerElapsed = Math.floor((performance.now() - gameState.timerStart)/1000);
          updateTimerDisplay();
        }
      }, 1000);
    }

    function updateTimerDisplay() {
      const seconds = gameState.timerElapsed % 60;
      const minutes = Math.floor(gameState.timerElapsed / 60);
      timerValueElem.textContent = 
        (minutes > 9 ? minutes : '0'+minutes) + ':' + (seconds > 9 ? seconds : '0'+seconds);
    }

    /********************
     * Input handling
     ********************/

    // Map mouse coords to board square
    function coordsToSquare(x, y) {
      const rect = canvas.getBoundingClientRect();
      const px = x - rect.left;
      const py = y - rect.top;
      if(px < 0 || py < 0 || px > rect.width || py > rect.height) return null;

      // Map px, py to row, col
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const scaledX = px * scaleX;
      const scaledY = py * scaleY;
      const col = Math.floor(scaledX / squareSize);
      const row = Math.floor(scaledY / squareSize);
      if(row < 0 || row > 7 || col < 0 || col > 7) return null;
      return {row, col};
    }

    // Mouse click or tap to select or move pieces
    canvas.addEventListener('mousedown', (e) => {
      if(gameState.gameOver) return;
      const pos = coordsToSquare(e.clientX, e.clientY);
      if(!pos) return;
      selectSquare(pos.row, pos.col);
    });

    // Keyboard controls for accessibility
    let keyboardCursor = {row: 7, col: 0}; // highlight position for keyboard navigation
    let keyboardSelecting = false;

    canvas.addEventListener('keydown', (e) => {
      if(gameState.gameOver) return;
      switch(e.key) {
        case 'ArrowUp':
          e.preventDefault();
          keyboardCursor.row = clamp(keyboardCursor.row -1, 0,7);
          break;
        case 'ArrowDown':
          e.preventDefault();
          keyboardCursor.row = clamp(keyboardCursor.row +1, 0,7);
          break;
        case 'ArrowLeft':
          e.preventDefault();
          keyboardCursor.col = clamp(keyboardCursor.col -1, 0,7);
          break;
        case 'ArrowRight':
          e.preventDefault();
          keyboardCursor.col = clamp(keyboardCursor.col +1, 0,7);
          break;
        case 'Enter':
        case ' ':
          e.preventDefault();
          if(keyboardSelecting) {
            // Try to move selected piece
            if(gameState.selectedPiece) {
              let pos = {row: keyboardCursor.row, col: keyboardCursor.col};
              const possibleMoves = gameState.legalMoves;
              const canMoveHere = possibleMoves.some(m => m.row === pos.row && m.col === pos.col);
              if(canMoveHere) {
                movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, pos.row, pos.col);
                keyboardSelecting = false;
                clearSelection();
              } else {
                keyboardSelecting = false;
                clearSelection();
              }
            }
          } else {
            // Select piece at cursor if valid
            const piece = gameState.board[keyboardCursor.row][keyboardCursor.col];
            if(piece && piece.color === (gameState.whiteToMove ? 'w' : 'b')) {
              gameState.selectedPiece = {row: keyboardCursor.row, col: keyboardCursor.col};
              updateLegalMoves();
              keyboardSelecting = true;
            }
          }
          break;
        case 'Escape':
          e.preventDefault();
          keyboardSelecting = false;
          clearSelection();
          break;
      }
      drawGame();
    });

    // Highlight keyboard cursor on board with blinking rectangle
    let keyboardCursorBlink = true;
    setInterval(() => {
      keyboardCursorBlink = !keyboardCursorBlink;
      drawGame();
    }, 500);

    /********************
     * Game loop and rendering
     ********************/
    function drawGame() {
      drawBoard();
      drawHighlights();
      drawSelection();
      drawPieces();

      // Draw keyboard cursor if visible
      if(canvas === document.activeElement) {
        ctx.lineWidth = 3;
        ctx.strokeStyle = keyboardCursorBlink ? '#ffd700' : '#fff';
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 12;
        ctx.strokeRect(
          keyboardCursor.col * squareSize + 3,
          keyboardCursor.row * squareSize + 3,
          squareSize - 6,
          squareSize - 6
        );
        ctx.shadowBlur = 0;
      }
    }

    // Main game loop via requestAnimationFrame
    let lastTimestamp = 0;
    function gameLoop(timestamp) {
      const delta = timestamp - lastTimestamp;
      lastTimestamp = timestamp;

      if(!gameState.gameOver && !gameState.isPaused) {
        // Animate moving piece if any
        if(gameState.animationState.movingPiece) {
          gameState.animationState.animationProgress += delta;
          const p = gameState.animationState;
          const progressRatio = Math.min(p.animationProgress / p.animationDuration, 1);

          // Clear and redraw board
          drawBoard();
          drawHighlights();

          // Draw all pieces except moving one
          for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
              if(r===p.animationFrom.row && c===p.animationFrom.col) continue;
              if(r===p.animationTo.row && c===p.animationTo.col) continue;
              const piece = gameState.board[r][c];
              if(piece) {
                drawPieceAt(r, c, piece);
              }
            }
          }

          // Draw moving piece at interpolated position
          const fromX = p.animationFrom.col * squareSize + squareSize/2;
          const fromY = p.animationFrom.row * squareSize + squareSize/2;
          const toX = p.animationTo.col * squareSize + squareSize/2;
          const toY = p.animationTo.row * squareSize + squareSize/2;
          const currX = fromX + (toX - fromX) * progressRatio;
          const currY = fromY + (toY - fromY) * progressRatio;

          drawPieceAtXY(currX, currY, p.movingPiece);

          if(progressRatio >= 1) {
            // Finish animation
            p.movingPiece = null;
            p.animationProgress = 0;
            p.animationFrom = null;
            p.animationTo = null;
          }
        } else {
          drawGame();
        }
      } else {
        drawGame();
      }

      requestAnimationFrame(gameLoop);
    }

    // Drawing single piece at board coords
    function drawPieceAt(row, col, piece) {
      const px = col*squareSize + squareSize/2;
      const py = row*squareSize + squareSize/2;
      drawPieceAtXY(px, py, piece);
    }
    function drawPieceAtXY(x, y, piece) {
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "48px 'Segoe UI Symbol', Arial, sans-serif";
      ctx.lineWidth = 2;

      const unicodePieces = {
        pw: '\u2659', pb: '\u265F',
        rw: '\u2656', rb: '\u265C',
        nw: '\u2658', nb: '\u265E',
        bw: '\u2657', bb: '\u265D',
        qw: '\u2655', qb: '\u265B',
        kw: '\u2654', kb: '\u265A'
      };

      let symbol = unicodePieces[piece.type + piece.color];
      ctx.shadowColor = piece.color === 'w' ? '#d3d3ffcc' : '#b080ffcc';
      ctx.shadowBlur = 16;
      ctx.fillStyle = piece.color === 'w' ? '#f0f0ff' : '#d2abff';
      ctx.fillText(symbol, x, y);
      ctx.shadowBlur = 0;
    }

    /********************
     * Event listeners for controls
     ********************/
    btnUndo.addEventListener('click', () => {
      undoMove();
      updateLegalMoves();
    });
    btnRestart.addEventListener('click', () => {
      restartGame();
    });
    btnPause.addEventListener('click', () => {
      gameState.isPaused = !gameState.isPaused;
      if(!gameState.isPaused) {
        resetTimer();
        lastTimestamp = performance.now();
      }
    });

    soundVolumeInput.addEventListener('input', (e) => {
      gameState.settings.soundVolume = parseFloat(e.target.value);
    });
    musicVolumeInput.addEventListener('input', (e) => {
      gameState.settings.musicVolume = parseFloat(e.target.value);
    });

    /********************
     * Achievements and power-ups placeholder functions
     ********************/
    function unlockAchievement(id, name, description) {
      if(gameState.unlockedAchievements[id]) return;
      gameState.unlockedAchievements[id] = true;
      gameState.achievements.push({id, name, description});
      updateAchievementsList();
      showAchievementPopup(name);
    }
    function updateAchievementsList() {
      achievementsListElem.innerHTML = '';
      if(gameState.achievements.length === 0) {
        achievementsListElem.innerHTML = '<li>No achievements yet.</li>';
      } else {
        gameState.achievements.forEach(a => {
          let li = document.createElement('li');
          li.textContent = a.name + ': ' + a.description;
          achievementsListElem.appendChild(li);
        });
      }
    }
    function showAchievementPopup(text) {
      achievementPopupElem.textContent = '';
      const icon = document.createElement('span');
      icon.className = 'material-icons';
      icon.textContent = 'stars';
      achievementPopupElem.appendChild(icon);
      const msg = document.createElement('span');
      msg.textContent = 'Achievement unlocked: ' + text;
      achievementPopupElem.appendChild(msg);
      achievementPopupElem.classList.add('show');
      setTimeout(() => {
        achievementPopupElem.classList.remove('show');
      }, 4000);
    }

    /********************
     * Initialization
     ********************/
    let gameStarted = false;
    function init() {
      setupBoard();
      updateLegalMoves();
      drawGame();
      lastTimestamp = performance.now();
      requestAnimationFrame(gameLoop);
      // Give focus to canvas for keyboard
      canvas.tabIndex = 0;
      canvas.focus();

      // Unlock starter achievement after 3 seconds
      setTimeout(() => {
        unlockAchievement('start', 'Game Started', 'You started a new chess game');
      }, 3000);
    }
    init();

    // Accessibility: keyboard focus outline
    canvas.addEventListener('focus', () => {
      drawGame();
    });
    canvas.addEventListener('blur', () => {
      drawGame();
    });

  </script>
</body>
</html>

```